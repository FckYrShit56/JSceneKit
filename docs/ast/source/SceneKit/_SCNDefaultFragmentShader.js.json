{
  "type": "File",
  "start": 0,
  "end": 13409,
  "loc": {
    "start": {
      "line": 1,
      "column": 0
    },
    "end": {
      "line": 460,
      "column": 0
    }
  },
  "program": {
    "type": "Program",
    "start": 0,
    "end": 13409,
    "loc": {
      "start": {
        "line": 1,
        "column": 0
      },
      "end": {
        "line": 460,
        "column": 0
      }
    },
    "sourceType": "module",
    "body": [
      {
        "type": "Identifier",
        "start": 40,
        "end": 13365,
        "loc": {
          "start": {
            "line": 6,
            "column": 0
          },
          "end": {
            "line": 456,
            "column": 1
          }
        },
        "declarations": [
          {
            "type": "VariableDeclarator",
            "start": 46,
            "end": 13365,
            "loc": {
              "start": {
                "line": 6,
                "column": 6
              },
              "end": {
                "line": 456,
                "column": 1
              }
            },
            "id": {
              "type": "Identifier",
              "start": 46,
              "end": 71,
              "loc": {
                "start": {
                  "line": 6,
                  "column": 6
                },
                "end": {
                  "line": 6,
                  "column": 31
                },
                "identifierName": "_SCNDefaultFragmentShader"
              },
              "name": "_SCNDefaultFragmentShader",
              "leadingComments": null
            },
            "init": {
              "type": "TemplateLiteral",
              "start": 76,
              "end": 13365,
              "loc": {
                "start": {
                  "line": 7,
                  "column": 1
                },
                "end": {
                  "line": 456,
                  "column": 1
                }
              },
              "expressions": [],
              "quasis": [
                {
                  "type": "TemplateElement",
                  "start": 77,
                  "end": 13364,
                  "loc": {
                    "start": {
                      "line": 7,
                      "column": 2
                    },
                    "end": {
                      "line": 456,
                      "column": 0
                    }
                  },
                  "value": {
                    "raw": "#version 300 es\n  precision mediump float;\n  precision highp sampler2DShadow;\n\n  uniform bool[12] textureFlags;\n  #define TEXTURE_EMISSION_INDEX 0\n  #define TEXTURE_AMBIENT_INDEX 1\n  #define TEXTURE_DIFFUSE_INDEX 2\n  #define TEXTURE_SPECULAR_INDEX 3\n  #define TEXTURE_REFLECTIVE_INDEX 4\n  #define TEXTURE_TRANSPARENT_INDEX 5\n  #define TEXTURE_MULTIPLY_INDEX 6\n  #define TEXTURE_NORMAL_INDEX 7\n  #define TEXTURE_AMBIENT_OCCLUSION_INDEX 8\n  #define TEXTURE_SELF_ILLUMINATION_INDEX 9\n  #define TEXTURE_METALNESS_INDEX 10\n  #define TEXTURE_ROUGHNESS_INDEX 11\n\n  uniform bool selfIllumination;\n\n  uniform sampler2D u_emissionTexture;\n  uniform sampler2D u_ambientTexture;\n  uniform sampler2D u_diffuseTexture;\n  uniform sampler2D u_specularTexture;\n  uniform samplerCube u_reflectiveTexture;\n  uniform sampler2D u_transparentTexture;\n  uniform sampler2D u_multiplyTexture;\n  uniform sampler2D u_normalTexture;\n  uniform sampler2D u_ambientOcclusionTexture;\n  uniform sampler2D u_selfIlluminationTexture;\n  uniform sampler2D u_metalnessTexture;\n  uniform sampler2D u_roughnessTexture;\n\n  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__\n  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__\n  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__\n  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__\n  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__\n  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__\n  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__\n\n  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)\n  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)\n\n  #define USE_SHADER_MODIFIER_SURFACE __USE_SHADER_MODIFIER_SURFACE__\n  #define USE_SHADER_MODIFIER_FRAGMENT __USE_SHADER_MODIFIER_FRAGMENT__\n\n  layout (std140) uniform cameraUniform {\n    vec4 position;\n    mat4 viewTransform;\n    mat4 inverseViewTransform;\n    mat4 viewProjectionTransform;\n  } camera;\n\n  layout (std140) uniform materialUniform {\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 normal;\n    vec4 reflective;\n    vec4 emission;\n    vec4 transparent;\n    vec4 multiply;\n    vec4 ambientOcclusion;\n    vec4 selfIllumination;\n    vec4 metalness;\n    vec4 roughness;\n    float shininess;\n    float fresnelExponent;\n  } material;\n\n  struct AmbientLight {\n    vec4 color;\n  };\n\n  struct SCNShaderLightingContribution {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n  } _lightingContribution;\n\n  struct DirectionalLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct DirectionalShadowLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n    vec4 shadowColor;\n    mat4 viewProjectionTransform;\n    mat4 shadowProjectionTransform;\n  };\n\n  struct OmniLight {\n    vec4 color;\n    vec4 position; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct ProbeLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct SpotLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  layout (std140) uniform lightUniform {\n    #if NUM_AMBIENT_LIGHTS > 0\n      AmbientLight ambient[NUM_AMBIENT_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    #endif\n    #if NUM_OMNI_LIGHTS > 0\n      OmniLight omni[NUM_OMNI_LIGHTS];\n    #endif\n    #if NUM_SPOT_LIGHTS > 0\n      SpotLight spot[NUM_SPOT_LIGHTS];\n    #endif\n    #if NUM_IES_LIGHTS > 0\n      IESLight ies[NUM_IES_LIGHTS];\n    #endif\n    #if NUM_PROBE_LIGHTS > 0\n      ProbeLight probe[NUM_PROBE_LIGHTS];\n    #endif\n    #if NUM_LIGHTS == 0\n      vec4 dummy;\n    #endif\n  } light;\n  #if NUM_SHADOW_LIGHTS > 0\n    in vec3 v_light[NUM_SHADOW_LIGHTS];\n  #endif\n  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n    in vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    in vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    uniform sampler2D u_shadowTexture0;\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 1\n      uniform sampler2D u_shadowTexture1;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 2\n      uniform sampler2D u_shadowTexture2;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 3\n      uniform sampler2D u_shadowTexture3;\n    #endif\n  #endif\n\n  layout (std140) uniform SCNLightsUniform {\n    vec4 direction0;\n    mat4 shadowMatrix0;\n  } scn_lights;\n\n  layout (std140) uniform fogUniform {\n    vec4 color;\n    float startDistance;\n    float endDistance;\n    float densityExponent;\n  } fog;\n\n  struct SCNShaderSurface {\n    vec3 view;\n    vec3 position;\n    vec3 normal;\n    vec2 normalTexcoord;\n    vec3 geometryNormal;\n    vec3 tangent;\n    vec3 bitangent;\n    vec4 ambient;\n    vec2 ambientTexcoord;\n    vec4 diffuse;\n    vec2 diffuseTexcoord;\n    vec4 specular;\n    vec2 specularTexcoord;\n    vec4 emission;\n    vec2 emissionTexcoord;\n    vec4 multiply;\n    vec2 multiplyTexcoord;\n    vec4 transparent;\n    vec2 transparentTexcoord;\n    vec4 reflective;\n    float ambientOcclusion;\n    float shininess;\n    float fresnel;\n    __USER_CUSTOM_SURFACE__\n  } _surface;\n\n  struct SCNShaderOutput {\n    vec4 color;\n  } _output;\n\n  vec2 poissonDisk[4] = vec2[](\n    vec2( -0.94201624, -0.39906216 ),\n    vec2( 0.94558609, -0.76890725 ),\n    vec2( -0.094184101, -0.92938870 ),\n    vec2( 0.34495938, 0.29387760 )\n  );\n\n  //#define kSCNTexcoordCount 2\n  //struct SCNShaderGeometry {\n  //  vec3 position;\n  //  vec3 normal;\n  //  vec4 tangent;\n  //  vec4 color;\n  //  vec2 texcoords[kSCNTexcoordCount];\n  //};\n\n  uniform float u_time;\n\n  in vec3 v_position;\n  in vec3 v_normal;\n  in vec2 v_texcoord0;\n  in vec2 v_texcoord1;\n  //in vec4 v_color;\n  in vec3 v_eye;\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  in float v_fogFactor;\n\n  //in SCNShaderGeometry _geometry;\n\n  out vec4 outColor;\n\n  __USER_CUSTOM_UNIFORM__\n\n  float saturate(float value) {\n    return clamp(value, 0.0, 1.0);\n  }\n\n  float convDepth(vec4 color) {\n    const float rMask = 1.0;\n    const float gMask = 1.0 / 255.0;\n    const float bMask = 1.0 / (255.0 * 255.0);\n    const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n    float depth = dot(color, vec4(rMask, gMask, bMask, aMask));\n    return depth * 2.0 - 1.0;\n  }\n\n  #if USE_SHADER_MODIFIER_SURFACE\n  void shaderModifierSurface() {\n    __SHADER_MODIFIER_SURFACE__\n  }\n  #endif\n\n  #if USE_SHADER_MODIFIER_FRAGMENT\n  void shaderModifierFragment() {\n    __SHADER_MODIFIER_FRAGMENT__\n  }\n  #endif\n\n    \n  void main() {\n    //_output.color = v_color;\n    //_output.color = vec4(0, 0, 0, 1);\n\n    //vec3 viewVec = normalize(v_eye);\n    //vec3 nom = normalize(v_normal);\n    _surface.view = normalize(v_eye);\n    _surface.position = v_position;\n    _surface.normal = normalize(v_normal);\n    _surface.tangent = normalize(v_tangent);\n    _surface.bitangent = normalize(v_bitangent);\n\n    // normal texture\n    if(textureFlags[TEXTURE_NORMAL_INDEX]){\n      mat3 tsInv = mat3(_surface.tangent, _surface.bitangent, _surface.normal);\n      vec3 color = normalize(texture(u_normalTexture, v_texcoord0).rgb * 2.0 - 1.0); // FIXME: check mappingChannel to decide which texture you use.\n      _surface.normal = normalize(tsInv * color);\n    }\n\n    //_surface.ambient = material.ambient;\n    _surface.ambient = vec4(0, 0, 0, 1); // FIXME: check: lock ambient with diffuse\n    _surface.diffuse = material.diffuse;\n    _surface.specular = material.specular;\n    _surface.emission = material.emission;\n    _surface.multiply = material.multiply;\n    _surface.transparent = material.transparent;\n    _surface.reflective = material.reflective;\n    _surface.ambientOcclusion = 1.0; // TODO: calculate AO\n    _surface.shininess = material.shininess;\n    _surface.fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent); // TODO: calculate coefficient\n\n    // TODO: check mapping channel for each material\n    _surface.ambientTexcoord = v_texcoord0;\n    _surface.diffuseTexcoord = v_texcoord0;\n    _surface.specularTexcoord = v_texcoord0;\n    if(selfIllumination){\n      _surface.emissionTexcoord = v_texcoord1;\n    }else{\n      _surface.emissionTexcoord = v_texcoord0;\n    }\n    _surface.multiplyTexcoord = v_texcoord0;\n    _surface.transparentTexcoord = v_texcoord0;\n\n    if(textureFlags[TEXTURE_AMBIENT_INDEX]){\n      _surface.ambient = texture(u_ambientTexture, _surface.ambientTexcoord);\n    }\n    if(textureFlags[TEXTURE_DIFFUSE_INDEX]){\n      _surface.diffuse = texture(u_diffuseTexture, _surface.diffuseTexcoord);\n      _surface.diffuse.a *= material.diffuse.a;\n    }\n    if(textureFlags[TEXTURE_SPECULAR_INDEX]){\n      _surface.specular = texture(u_specularTexture, _surface.specularTexcoord);\n    }\n    if(textureFlags[TEXTURE_EMISSION_INDEX]){\n      _surface.emission = texture(u_emissionTexture, _surface.emissionTexcoord);\n    }\n    if(textureFlags[TEXTURE_MULTIPLY_INDEX]){\n      _surface.multiply = texture(u_multiplyTexture, _surface.multiplyTexcoord);\n    }\n    if(textureFlags[TEXTURE_TRANSPARENT_INDEX]){\n      _surface.transparent = texture(u_transparentTexture, _surface.transparentTexcoord);\n    }\n\n    __USER_CUSTOM_TEXCOORD__\n\n    #if USE_SHADER_MODIFIER_SURFACE\n      shaderModifierSurface();\n    #endif\n\n    // Lighting\n    int numLights = 0;\n    _lightingContribution.ambient = vec3(0);\n    _lightingContribution.diffuse = vec3(0);\n    _lightingContribution.specular = vec3(0);\n\n    #if NUM_AMBIENT_LIGHTS > 0\n      for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){\n        _lightingContribution.ambient += light.ambient[i].color.rgb;\n      }\n    #endif\n\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.directional[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.directional[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(specular);\n        }\n      }\n      numLights += NUM_DIRECTIONAL_LIGHTS;\n    #endif\n\n    #if NUM_OMNI_LIGHTS > 0\n      for(int i=0; i<NUM_OMNI_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.omni[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.omni[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(1, 1, 1) * specular;\n        }\n      }\n      numLights += NUM_OMNI_LIGHTS;\n    #endif\n\n    #if NUM_SPOT_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_IES_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_PROBE_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    __FS_LIGHTING__\n\n\n    // calculate color\n    _output.color = vec4(0, 0, 0, _surface.diffuse.a);\n\n    vec3 D = _lightingContribution.diffuse;\n\n    // lock ambient with diffuse\n    D += _lightingContribution.ambient * _surface.ambientOcclusion;\n\n    // emission\n    if(selfIllumination){\n      D += _surface.emission.rgb;\n    }\n\n    // diffuse\n    _output.color.rgb = _surface.diffuse.rgb * D;\n\n    vec3 S = _lightingContribution.specular;\n    //S += _surface.reflective.rgb * _surface.ambientOcclusion;\n    S *= _surface.specular.rgb;\n    _output.color.rgb += S;\n\n    // ambient\n    _output.color.rgb += _surface.ambient.rgb * _lightingContribution.ambient;\n\n    if(!selfIllumination){\n      _output.color.rgb += _surface.emission.rgb;\n    }\n\n    // multiply\n    _output.color.rgb *= _surface.multiply.rgb;\n\n    // fresnel reflection\n    if(textureFlags[TEXTURE_REFLECTIVE_INDEX]){\n      vec3 r = reflect(_surface.view, _surface.normal);\n      //float fresnel = f0 + (1.0 - f0) * pow(1.0 - clamp(dot(viewVec, nom), 0.0, 1.0), material.fresnelExponent);\n      //float fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent);\n      _output.color.rgb += texture(u_reflectiveTexture, r).rgb * _surface.fresnel;\n    }\n\n    float fogFactor = pow(v_fogFactor, fog.densityExponent);\n    _output.color = mix(_output.color, fog.color, fogFactor);\n\n    _output.color.rgb *= _surface.diffuse.a;\n\n    #if USE_SHADER_MODIFIER_FRAGMENT\n      shaderModifierFragment();\n    #endif\n\n    if(_output.color.a <= 0.0){\n      // avoid overwriting the depth buffer\n      discard;\n    }\n\n    outColor = _output.color;\n\n    // linear To sRGB\n    //outColor.rgb = pow(_output.color.rgb, vec3(1.0/2.2));\n    //outColor.a = _output.color.a;\n  }\n",
                    "cooked": "#version 300 es\n  precision mediump float;\n  precision highp sampler2DShadow;\n\n  uniform bool[12] textureFlags;\n  #define TEXTURE_EMISSION_INDEX 0\n  #define TEXTURE_AMBIENT_INDEX 1\n  #define TEXTURE_DIFFUSE_INDEX 2\n  #define TEXTURE_SPECULAR_INDEX 3\n  #define TEXTURE_REFLECTIVE_INDEX 4\n  #define TEXTURE_TRANSPARENT_INDEX 5\n  #define TEXTURE_MULTIPLY_INDEX 6\n  #define TEXTURE_NORMAL_INDEX 7\n  #define TEXTURE_AMBIENT_OCCLUSION_INDEX 8\n  #define TEXTURE_SELF_ILLUMINATION_INDEX 9\n  #define TEXTURE_METALNESS_INDEX 10\n  #define TEXTURE_ROUGHNESS_INDEX 11\n\n  uniform bool selfIllumination;\n\n  uniform sampler2D u_emissionTexture;\n  uniform sampler2D u_ambientTexture;\n  uniform sampler2D u_diffuseTexture;\n  uniform sampler2D u_specularTexture;\n  uniform samplerCube u_reflectiveTexture;\n  uniform sampler2D u_transparentTexture;\n  uniform sampler2D u_multiplyTexture;\n  uniform sampler2D u_normalTexture;\n  uniform sampler2D u_ambientOcclusionTexture;\n  uniform sampler2D u_selfIlluminationTexture;\n  uniform sampler2D u_metalnessTexture;\n  uniform sampler2D u_roughnessTexture;\n\n  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__\n  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__\n  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__\n  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__\n  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__\n  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__\n  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__\n\n  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)\n  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)\n\n  #define USE_SHADER_MODIFIER_SURFACE __USE_SHADER_MODIFIER_SURFACE__\n  #define USE_SHADER_MODIFIER_FRAGMENT __USE_SHADER_MODIFIER_FRAGMENT__\n\n  layout (std140) uniform cameraUniform {\n    vec4 position;\n    mat4 viewTransform;\n    mat4 inverseViewTransform;\n    mat4 viewProjectionTransform;\n  } camera;\n\n  layout (std140) uniform materialUniform {\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 normal;\n    vec4 reflective;\n    vec4 emission;\n    vec4 transparent;\n    vec4 multiply;\n    vec4 ambientOcclusion;\n    vec4 selfIllumination;\n    vec4 metalness;\n    vec4 roughness;\n    float shininess;\n    float fresnelExponent;\n  } material;\n\n  struct AmbientLight {\n    vec4 color;\n  };\n\n  struct SCNShaderLightingContribution {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n  } _lightingContribution;\n\n  struct DirectionalLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct DirectionalShadowLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n    vec4 shadowColor;\n    mat4 viewProjectionTransform;\n    mat4 shadowProjectionTransform;\n  };\n\n  struct OmniLight {\n    vec4 color;\n    vec4 position; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct ProbeLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct SpotLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  layout (std140) uniform lightUniform {\n    #if NUM_AMBIENT_LIGHTS > 0\n      AmbientLight ambient[NUM_AMBIENT_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    #endif\n    #if NUM_OMNI_LIGHTS > 0\n      OmniLight omni[NUM_OMNI_LIGHTS];\n    #endif\n    #if NUM_SPOT_LIGHTS > 0\n      SpotLight spot[NUM_SPOT_LIGHTS];\n    #endif\n    #if NUM_IES_LIGHTS > 0\n      IESLight ies[NUM_IES_LIGHTS];\n    #endif\n    #if NUM_PROBE_LIGHTS > 0\n      ProbeLight probe[NUM_PROBE_LIGHTS];\n    #endif\n    #if NUM_LIGHTS == 0\n      vec4 dummy;\n    #endif\n  } light;\n  #if NUM_SHADOW_LIGHTS > 0\n    in vec3 v_light[NUM_SHADOW_LIGHTS];\n  #endif\n  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n    in vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    in vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    uniform sampler2D u_shadowTexture0;\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 1\n      uniform sampler2D u_shadowTexture1;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 2\n      uniform sampler2D u_shadowTexture2;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 3\n      uniform sampler2D u_shadowTexture3;\n    #endif\n  #endif\n\n  layout (std140) uniform SCNLightsUniform {\n    vec4 direction0;\n    mat4 shadowMatrix0;\n  } scn_lights;\n\n  layout (std140) uniform fogUniform {\n    vec4 color;\n    float startDistance;\n    float endDistance;\n    float densityExponent;\n  } fog;\n\n  struct SCNShaderSurface {\n    vec3 view;\n    vec3 position;\n    vec3 normal;\n    vec2 normalTexcoord;\n    vec3 geometryNormal;\n    vec3 tangent;\n    vec3 bitangent;\n    vec4 ambient;\n    vec2 ambientTexcoord;\n    vec4 diffuse;\n    vec2 diffuseTexcoord;\n    vec4 specular;\n    vec2 specularTexcoord;\n    vec4 emission;\n    vec2 emissionTexcoord;\n    vec4 multiply;\n    vec2 multiplyTexcoord;\n    vec4 transparent;\n    vec2 transparentTexcoord;\n    vec4 reflective;\n    float ambientOcclusion;\n    float shininess;\n    float fresnel;\n    __USER_CUSTOM_SURFACE__\n  } _surface;\n\n  struct SCNShaderOutput {\n    vec4 color;\n  } _output;\n\n  vec2 poissonDisk[4] = vec2[](\n    vec2( -0.94201624, -0.39906216 ),\n    vec2( 0.94558609, -0.76890725 ),\n    vec2( -0.094184101, -0.92938870 ),\n    vec2( 0.34495938, 0.29387760 )\n  );\n\n  //#define kSCNTexcoordCount 2\n  //struct SCNShaderGeometry {\n  //  vec3 position;\n  //  vec3 normal;\n  //  vec4 tangent;\n  //  vec4 color;\n  //  vec2 texcoords[kSCNTexcoordCount];\n  //};\n\n  uniform float u_time;\n\n  in vec3 v_position;\n  in vec3 v_normal;\n  in vec2 v_texcoord0;\n  in vec2 v_texcoord1;\n  //in vec4 v_color;\n  in vec3 v_eye;\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  in float v_fogFactor;\n\n  //in SCNShaderGeometry _geometry;\n\n  out vec4 outColor;\n\n  __USER_CUSTOM_UNIFORM__\n\n  float saturate(float value) {\n    return clamp(value, 0.0, 1.0);\n  }\n\n  float convDepth(vec4 color) {\n    const float rMask = 1.0;\n    const float gMask = 1.0 / 255.0;\n    const float bMask = 1.0 / (255.0 * 255.0);\n    const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n    float depth = dot(color, vec4(rMask, gMask, bMask, aMask));\n    return depth * 2.0 - 1.0;\n  }\n\n  #if USE_SHADER_MODIFIER_SURFACE\n  void shaderModifierSurface() {\n    __SHADER_MODIFIER_SURFACE__\n  }\n  #endif\n\n  #if USE_SHADER_MODIFIER_FRAGMENT\n  void shaderModifierFragment() {\n    __SHADER_MODIFIER_FRAGMENT__\n  }\n  #endif\n\n    \n  void main() {\n    //_output.color = v_color;\n    //_output.color = vec4(0, 0, 0, 1);\n\n    //vec3 viewVec = normalize(v_eye);\n    //vec3 nom = normalize(v_normal);\n    _surface.view = normalize(v_eye);\n    _surface.position = v_position;\n    _surface.normal = normalize(v_normal);\n    _surface.tangent = normalize(v_tangent);\n    _surface.bitangent = normalize(v_bitangent);\n\n    // normal texture\n    if(textureFlags[TEXTURE_NORMAL_INDEX]){\n      mat3 tsInv = mat3(_surface.tangent, _surface.bitangent, _surface.normal);\n      vec3 color = normalize(texture(u_normalTexture, v_texcoord0).rgb * 2.0 - 1.0); // FIXME: check mappingChannel to decide which texture you use.\n      _surface.normal = normalize(tsInv * color);\n    }\n\n    //_surface.ambient = material.ambient;\n    _surface.ambient = vec4(0, 0, 0, 1); // FIXME: check: lock ambient with diffuse\n    _surface.diffuse = material.diffuse;\n    _surface.specular = material.specular;\n    _surface.emission = material.emission;\n    _surface.multiply = material.multiply;\n    _surface.transparent = material.transparent;\n    _surface.reflective = material.reflective;\n    _surface.ambientOcclusion = 1.0; // TODO: calculate AO\n    _surface.shininess = material.shininess;\n    _surface.fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent); // TODO: calculate coefficient\n\n    // TODO: check mapping channel for each material\n    _surface.ambientTexcoord = v_texcoord0;\n    _surface.diffuseTexcoord = v_texcoord0;\n    _surface.specularTexcoord = v_texcoord0;\n    if(selfIllumination){\n      _surface.emissionTexcoord = v_texcoord1;\n    }else{\n      _surface.emissionTexcoord = v_texcoord0;\n    }\n    _surface.multiplyTexcoord = v_texcoord0;\n    _surface.transparentTexcoord = v_texcoord0;\n\n    if(textureFlags[TEXTURE_AMBIENT_INDEX]){\n      _surface.ambient = texture(u_ambientTexture, _surface.ambientTexcoord);\n    }\n    if(textureFlags[TEXTURE_DIFFUSE_INDEX]){\n      _surface.diffuse = texture(u_diffuseTexture, _surface.diffuseTexcoord);\n      _surface.diffuse.a *= material.diffuse.a;\n    }\n    if(textureFlags[TEXTURE_SPECULAR_INDEX]){\n      _surface.specular = texture(u_specularTexture, _surface.specularTexcoord);\n    }\n    if(textureFlags[TEXTURE_EMISSION_INDEX]){\n      _surface.emission = texture(u_emissionTexture, _surface.emissionTexcoord);\n    }\n    if(textureFlags[TEXTURE_MULTIPLY_INDEX]){\n      _surface.multiply = texture(u_multiplyTexture, _surface.multiplyTexcoord);\n    }\n    if(textureFlags[TEXTURE_TRANSPARENT_INDEX]){\n      _surface.transparent = texture(u_transparentTexture, _surface.transparentTexcoord);\n    }\n\n    __USER_CUSTOM_TEXCOORD__\n\n    #if USE_SHADER_MODIFIER_SURFACE\n      shaderModifierSurface();\n    #endif\n\n    // Lighting\n    int numLights = 0;\n    _lightingContribution.ambient = vec3(0);\n    _lightingContribution.diffuse = vec3(0);\n    _lightingContribution.specular = vec3(0);\n\n    #if NUM_AMBIENT_LIGHTS > 0\n      for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){\n        _lightingContribution.ambient += light.ambient[i].color.rgb;\n      }\n    #endif\n\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.directional[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.directional[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(specular);\n        }\n      }\n      numLights += NUM_DIRECTIONAL_LIGHTS;\n    #endif\n\n    #if NUM_OMNI_LIGHTS > 0\n      for(int i=0; i<NUM_OMNI_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.omni[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.omni[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(1, 1, 1) * specular;\n        }\n      }\n      numLights += NUM_OMNI_LIGHTS;\n    #endif\n\n    #if NUM_SPOT_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_IES_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_PROBE_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    __FS_LIGHTING__\n\n\n    // calculate color\n    _output.color = vec4(0, 0, 0, _surface.diffuse.a);\n\n    vec3 D = _lightingContribution.diffuse;\n\n    // lock ambient with diffuse\n    D += _lightingContribution.ambient * _surface.ambientOcclusion;\n\n    // emission\n    if(selfIllumination){\n      D += _surface.emission.rgb;\n    }\n\n    // diffuse\n    _output.color.rgb = _surface.diffuse.rgb * D;\n\n    vec3 S = _lightingContribution.specular;\n    //S += _surface.reflective.rgb * _surface.ambientOcclusion;\n    S *= _surface.specular.rgb;\n    _output.color.rgb += S;\n\n    // ambient\n    _output.color.rgb += _surface.ambient.rgb * _lightingContribution.ambient;\n\n    if(!selfIllumination){\n      _output.color.rgb += _surface.emission.rgb;\n    }\n\n    // multiply\n    _output.color.rgb *= _surface.multiply.rgb;\n\n    // fresnel reflection\n    if(textureFlags[TEXTURE_REFLECTIVE_INDEX]){\n      vec3 r = reflect(_surface.view, _surface.normal);\n      //float fresnel = f0 + (1.0 - f0) * pow(1.0 - clamp(dot(viewVec, nom), 0.0, 1.0), material.fresnelExponent);\n      //float fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent);\n      _output.color.rgb += texture(u_reflectiveTexture, r).rgb * _surface.fresnel;\n    }\n\n    float fogFactor = pow(v_fogFactor, fog.densityExponent);\n    _output.color = mix(_output.color, fog.color, fogFactor);\n\n    _output.color.rgb *= _surface.diffuse.a;\n\n    #if USE_SHADER_MODIFIER_FRAGMENT\n      shaderModifierFragment();\n    #endif\n\n    if(_output.color.a <= 0.0){\n      // avoid overwriting the depth buffer\n      discard;\n    }\n\n    outColor = _output.color;\n\n    // linear To sRGB\n    //outColor.rgb = pow(_output.color.rgb, vec3(1.0/2.2));\n    //outColor.a = _output.color.a;\n  }\n"
                  },
                  "tail": true
                }
              ]
            },
            "leadingComments": null
          }
        ],
        "kind": "const",
        "leadingComments": [],
        "name": "_",
        "trailingComments": []
      },
      {
        "type": "Identifier",
        "start": 13367,
        "end": 13407,
        "loc": {
          "start": {
            "line": 458,
            "column": 0
          },
          "end": {
            "line": 458,
            "column": 40
          }
        },
        "declaration": {
          "type": "Identifier",
          "start": 13382,
          "end": 13407,
          "loc": {
            "start": {
              "line": 458,
              "column": 15
            },
            "end": {
              "line": 458,
              "column": 40
            },
            "identifierName": "_SCNDefaultFragmentShader"
          },
          "name": "_SCNDefaultFragmentShader"
        },
        "name": "_",
        "leadingComments": [],
        "trailingComments": []
      },
      {
        "type": "ExportDefaultDeclaration",
        "start": 13367,
        "end": 13407,
        "loc": {
          "start": {
            "line": 458,
            "column": 0
          },
          "end": {
            "line": 458,
            "column": 40
          }
        },
        "declaration": {
          "type": "VariableDeclaration",
          "start": 40,
          "end": 13365,
          "loc": {
            "start": {
              "line": 6,
              "column": 0
            },
            "end": {
              "line": 456,
              "column": 1
            }
          },
          "declarations": [
            {
              "type": "VariableDeclarator",
              "start": 46,
              "end": 13365,
              "loc": {
                "start": {
                  "line": 6,
                  "column": 6
                },
                "end": {
                  "line": 456,
                  "column": 1
                }
              },
              "id": {
                "type": "Identifier",
                "start": 46,
                "end": 71,
                "loc": {
                  "start": {
                    "line": 6,
                    "column": 6
                  },
                  "end": {
                    "line": 6,
                    "column": 31
                  },
                  "identifierName": "_SCNDefaultFragmentShader"
                },
                "name": "_SCNDefaultFragmentShader",
                "leadingComments": null
              },
              "init": {
                "type": "TemplateLiteral",
                "start": 76,
                "end": 13365,
                "loc": {
                  "start": {
                    "line": 7,
                    "column": 1
                  },
                  "end": {
                    "line": 456,
                    "column": 1
                  }
                },
                "expressions": [],
                "quasis": [
                  {
                    "type": "TemplateElement",
                    "start": 77,
                    "end": 13364,
                    "loc": {
                      "start": {
                        "line": 7,
                        "column": 2
                      },
                      "end": {
                        "line": 456,
                        "column": 0
                      }
                    },
                    "value": {
                      "raw": "#version 300 es\n  precision mediump float;\n  precision highp sampler2DShadow;\n\n  uniform bool[12] textureFlags;\n  #define TEXTURE_EMISSION_INDEX 0\n  #define TEXTURE_AMBIENT_INDEX 1\n  #define TEXTURE_DIFFUSE_INDEX 2\n  #define TEXTURE_SPECULAR_INDEX 3\n  #define TEXTURE_REFLECTIVE_INDEX 4\n  #define TEXTURE_TRANSPARENT_INDEX 5\n  #define TEXTURE_MULTIPLY_INDEX 6\n  #define TEXTURE_NORMAL_INDEX 7\n  #define TEXTURE_AMBIENT_OCCLUSION_INDEX 8\n  #define TEXTURE_SELF_ILLUMINATION_INDEX 9\n  #define TEXTURE_METALNESS_INDEX 10\n  #define TEXTURE_ROUGHNESS_INDEX 11\n\n  uniform bool selfIllumination;\n\n  uniform sampler2D u_emissionTexture;\n  uniform sampler2D u_ambientTexture;\n  uniform sampler2D u_diffuseTexture;\n  uniform sampler2D u_specularTexture;\n  uniform samplerCube u_reflectiveTexture;\n  uniform sampler2D u_transparentTexture;\n  uniform sampler2D u_multiplyTexture;\n  uniform sampler2D u_normalTexture;\n  uniform sampler2D u_ambientOcclusionTexture;\n  uniform sampler2D u_selfIlluminationTexture;\n  uniform sampler2D u_metalnessTexture;\n  uniform sampler2D u_roughnessTexture;\n\n  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__\n  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__\n  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__\n  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__\n  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__\n  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__\n  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__\n\n  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)\n  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)\n\n  #define USE_SHADER_MODIFIER_SURFACE __USE_SHADER_MODIFIER_SURFACE__\n  #define USE_SHADER_MODIFIER_FRAGMENT __USE_SHADER_MODIFIER_FRAGMENT__\n\n  layout (std140) uniform cameraUniform {\n    vec4 position;\n    mat4 viewTransform;\n    mat4 inverseViewTransform;\n    mat4 viewProjectionTransform;\n  } camera;\n\n  layout (std140) uniform materialUniform {\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 normal;\n    vec4 reflective;\n    vec4 emission;\n    vec4 transparent;\n    vec4 multiply;\n    vec4 ambientOcclusion;\n    vec4 selfIllumination;\n    vec4 metalness;\n    vec4 roughness;\n    float shininess;\n    float fresnelExponent;\n  } material;\n\n  struct AmbientLight {\n    vec4 color;\n  };\n\n  struct SCNShaderLightingContribution {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n  } _lightingContribution;\n\n  struct DirectionalLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct DirectionalShadowLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n    vec4 shadowColor;\n    mat4 viewProjectionTransform;\n    mat4 shadowProjectionTransform;\n  };\n\n  struct OmniLight {\n    vec4 color;\n    vec4 position; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct ProbeLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct SpotLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  layout (std140) uniform lightUniform {\n    #if NUM_AMBIENT_LIGHTS > 0\n      AmbientLight ambient[NUM_AMBIENT_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    #endif\n    #if NUM_OMNI_LIGHTS > 0\n      OmniLight omni[NUM_OMNI_LIGHTS];\n    #endif\n    #if NUM_SPOT_LIGHTS > 0\n      SpotLight spot[NUM_SPOT_LIGHTS];\n    #endif\n    #if NUM_IES_LIGHTS > 0\n      IESLight ies[NUM_IES_LIGHTS];\n    #endif\n    #if NUM_PROBE_LIGHTS > 0\n      ProbeLight probe[NUM_PROBE_LIGHTS];\n    #endif\n    #if NUM_LIGHTS == 0\n      vec4 dummy;\n    #endif\n  } light;\n  #if NUM_SHADOW_LIGHTS > 0\n    in vec3 v_light[NUM_SHADOW_LIGHTS];\n  #endif\n  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n    in vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    in vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    uniform sampler2D u_shadowTexture0;\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 1\n      uniform sampler2D u_shadowTexture1;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 2\n      uniform sampler2D u_shadowTexture2;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 3\n      uniform sampler2D u_shadowTexture3;\n    #endif\n  #endif\n\n  layout (std140) uniform SCNLightsUniform {\n    vec4 direction0;\n    mat4 shadowMatrix0;\n  } scn_lights;\n\n  layout (std140) uniform fogUniform {\n    vec4 color;\n    float startDistance;\n    float endDistance;\n    float densityExponent;\n  } fog;\n\n  struct SCNShaderSurface {\n    vec3 view;\n    vec3 position;\n    vec3 normal;\n    vec2 normalTexcoord;\n    vec3 geometryNormal;\n    vec3 tangent;\n    vec3 bitangent;\n    vec4 ambient;\n    vec2 ambientTexcoord;\n    vec4 diffuse;\n    vec2 diffuseTexcoord;\n    vec4 specular;\n    vec2 specularTexcoord;\n    vec4 emission;\n    vec2 emissionTexcoord;\n    vec4 multiply;\n    vec2 multiplyTexcoord;\n    vec4 transparent;\n    vec2 transparentTexcoord;\n    vec4 reflective;\n    float ambientOcclusion;\n    float shininess;\n    float fresnel;\n    __USER_CUSTOM_SURFACE__\n  } _surface;\n\n  struct SCNShaderOutput {\n    vec4 color;\n  } _output;\n\n  vec2 poissonDisk[4] = vec2[](\n    vec2( -0.94201624, -0.39906216 ),\n    vec2( 0.94558609, -0.76890725 ),\n    vec2( -0.094184101, -0.92938870 ),\n    vec2( 0.34495938, 0.29387760 )\n  );\n\n  //#define kSCNTexcoordCount 2\n  //struct SCNShaderGeometry {\n  //  vec3 position;\n  //  vec3 normal;\n  //  vec4 tangent;\n  //  vec4 color;\n  //  vec2 texcoords[kSCNTexcoordCount];\n  //};\n\n  uniform float u_time;\n\n  in vec3 v_position;\n  in vec3 v_normal;\n  in vec2 v_texcoord0;\n  in vec2 v_texcoord1;\n  //in vec4 v_color;\n  in vec3 v_eye;\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  in float v_fogFactor;\n\n  //in SCNShaderGeometry _geometry;\n\n  out vec4 outColor;\n\n  __USER_CUSTOM_UNIFORM__\n\n  float saturate(float value) {\n    return clamp(value, 0.0, 1.0);\n  }\n\n  float convDepth(vec4 color) {\n    const float rMask = 1.0;\n    const float gMask = 1.0 / 255.0;\n    const float bMask = 1.0 / (255.0 * 255.0);\n    const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n    float depth = dot(color, vec4(rMask, gMask, bMask, aMask));\n    return depth * 2.0 - 1.0;\n  }\n\n  #if USE_SHADER_MODIFIER_SURFACE\n  void shaderModifierSurface() {\n    __SHADER_MODIFIER_SURFACE__\n  }\n  #endif\n\n  #if USE_SHADER_MODIFIER_FRAGMENT\n  void shaderModifierFragment() {\n    __SHADER_MODIFIER_FRAGMENT__\n  }\n  #endif\n\n    \n  void main() {\n    //_output.color = v_color;\n    //_output.color = vec4(0, 0, 0, 1);\n\n    //vec3 viewVec = normalize(v_eye);\n    //vec3 nom = normalize(v_normal);\n    _surface.view = normalize(v_eye);\n    _surface.position = v_position;\n    _surface.normal = normalize(v_normal);\n    _surface.tangent = normalize(v_tangent);\n    _surface.bitangent = normalize(v_bitangent);\n\n    // normal texture\n    if(textureFlags[TEXTURE_NORMAL_INDEX]){\n      mat3 tsInv = mat3(_surface.tangent, _surface.bitangent, _surface.normal);\n      vec3 color = normalize(texture(u_normalTexture, v_texcoord0).rgb * 2.0 - 1.0); // FIXME: check mappingChannel to decide which texture you use.\n      _surface.normal = normalize(tsInv * color);\n    }\n\n    //_surface.ambient = material.ambient;\n    _surface.ambient = vec4(0, 0, 0, 1); // FIXME: check: lock ambient with diffuse\n    _surface.diffuse = material.diffuse;\n    _surface.specular = material.specular;\n    _surface.emission = material.emission;\n    _surface.multiply = material.multiply;\n    _surface.transparent = material.transparent;\n    _surface.reflective = material.reflective;\n    _surface.ambientOcclusion = 1.0; // TODO: calculate AO\n    _surface.shininess = material.shininess;\n    _surface.fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent); // TODO: calculate coefficient\n\n    // TODO: check mapping channel for each material\n    _surface.ambientTexcoord = v_texcoord0;\n    _surface.diffuseTexcoord = v_texcoord0;\n    _surface.specularTexcoord = v_texcoord0;\n    if(selfIllumination){\n      _surface.emissionTexcoord = v_texcoord1;\n    }else{\n      _surface.emissionTexcoord = v_texcoord0;\n    }\n    _surface.multiplyTexcoord = v_texcoord0;\n    _surface.transparentTexcoord = v_texcoord0;\n\n    if(textureFlags[TEXTURE_AMBIENT_INDEX]){\n      _surface.ambient = texture(u_ambientTexture, _surface.ambientTexcoord);\n    }\n    if(textureFlags[TEXTURE_DIFFUSE_INDEX]){\n      _surface.diffuse = texture(u_diffuseTexture, _surface.diffuseTexcoord);\n      _surface.diffuse.a *= material.diffuse.a;\n    }\n    if(textureFlags[TEXTURE_SPECULAR_INDEX]){\n      _surface.specular = texture(u_specularTexture, _surface.specularTexcoord);\n    }\n    if(textureFlags[TEXTURE_EMISSION_INDEX]){\n      _surface.emission = texture(u_emissionTexture, _surface.emissionTexcoord);\n    }\n    if(textureFlags[TEXTURE_MULTIPLY_INDEX]){\n      _surface.multiply = texture(u_multiplyTexture, _surface.multiplyTexcoord);\n    }\n    if(textureFlags[TEXTURE_TRANSPARENT_INDEX]){\n      _surface.transparent = texture(u_transparentTexture, _surface.transparentTexcoord);\n    }\n\n    __USER_CUSTOM_TEXCOORD__\n\n    #if USE_SHADER_MODIFIER_SURFACE\n      shaderModifierSurface();\n    #endif\n\n    // Lighting\n    int numLights = 0;\n    _lightingContribution.ambient = vec3(0);\n    _lightingContribution.diffuse = vec3(0);\n    _lightingContribution.specular = vec3(0);\n\n    #if NUM_AMBIENT_LIGHTS > 0\n      for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){\n        _lightingContribution.ambient += light.ambient[i].color.rgb;\n      }\n    #endif\n\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.directional[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.directional[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(specular);\n        }\n      }\n      numLights += NUM_DIRECTIONAL_LIGHTS;\n    #endif\n\n    #if NUM_OMNI_LIGHTS > 0\n      for(int i=0; i<NUM_OMNI_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.omni[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.omni[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(1, 1, 1) * specular;\n        }\n      }\n      numLights += NUM_OMNI_LIGHTS;\n    #endif\n\n    #if NUM_SPOT_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_IES_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_PROBE_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    __FS_LIGHTING__\n\n\n    // calculate color\n    _output.color = vec4(0, 0, 0, _surface.diffuse.a);\n\n    vec3 D = _lightingContribution.diffuse;\n\n    // lock ambient with diffuse\n    D += _lightingContribution.ambient * _surface.ambientOcclusion;\n\n    // emission\n    if(selfIllumination){\n      D += _surface.emission.rgb;\n    }\n\n    // diffuse\n    _output.color.rgb = _surface.diffuse.rgb * D;\n\n    vec3 S = _lightingContribution.specular;\n    //S += _surface.reflective.rgb * _surface.ambientOcclusion;\n    S *= _surface.specular.rgb;\n    _output.color.rgb += S;\n\n    // ambient\n    _output.color.rgb += _surface.ambient.rgb * _lightingContribution.ambient;\n\n    if(!selfIllumination){\n      _output.color.rgb += _surface.emission.rgb;\n    }\n\n    // multiply\n    _output.color.rgb *= _surface.multiply.rgb;\n\n    // fresnel reflection\n    if(textureFlags[TEXTURE_REFLECTIVE_INDEX]){\n      vec3 r = reflect(_surface.view, _surface.normal);\n      //float fresnel = f0 + (1.0 - f0) * pow(1.0 - clamp(dot(viewVec, nom), 0.0, 1.0), material.fresnelExponent);\n      //float fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent);\n      _output.color.rgb += texture(u_reflectiveTexture, r).rgb * _surface.fresnel;\n    }\n\n    float fogFactor = pow(v_fogFactor, fog.densityExponent);\n    _output.color = mix(_output.color, fog.color, fogFactor);\n\n    _output.color.rgb *= _surface.diffuse.a;\n\n    #if USE_SHADER_MODIFIER_FRAGMENT\n      shaderModifierFragment();\n    #endif\n\n    if(_output.color.a <= 0.0){\n      // avoid overwriting the depth buffer\n      discard;\n    }\n\n    outColor = _output.color;\n\n    // linear To sRGB\n    //outColor.rgb = pow(_output.color.rgb, vec3(1.0/2.2));\n    //outColor.a = _output.color.a;\n  }\n",
                      "cooked": "#version 300 es\n  precision mediump float;\n  precision highp sampler2DShadow;\n\n  uniform bool[12] textureFlags;\n  #define TEXTURE_EMISSION_INDEX 0\n  #define TEXTURE_AMBIENT_INDEX 1\n  #define TEXTURE_DIFFUSE_INDEX 2\n  #define TEXTURE_SPECULAR_INDEX 3\n  #define TEXTURE_REFLECTIVE_INDEX 4\n  #define TEXTURE_TRANSPARENT_INDEX 5\n  #define TEXTURE_MULTIPLY_INDEX 6\n  #define TEXTURE_NORMAL_INDEX 7\n  #define TEXTURE_AMBIENT_OCCLUSION_INDEX 8\n  #define TEXTURE_SELF_ILLUMINATION_INDEX 9\n  #define TEXTURE_METALNESS_INDEX 10\n  #define TEXTURE_ROUGHNESS_INDEX 11\n\n  uniform bool selfIllumination;\n\n  uniform sampler2D u_emissionTexture;\n  uniform sampler2D u_ambientTexture;\n  uniform sampler2D u_diffuseTexture;\n  uniform sampler2D u_specularTexture;\n  uniform samplerCube u_reflectiveTexture;\n  uniform sampler2D u_transparentTexture;\n  uniform sampler2D u_multiplyTexture;\n  uniform sampler2D u_normalTexture;\n  uniform sampler2D u_ambientOcclusionTexture;\n  uniform sampler2D u_selfIlluminationTexture;\n  uniform sampler2D u_metalnessTexture;\n  uniform sampler2D u_roughnessTexture;\n\n  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__\n  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__\n  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__\n  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__\n  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__\n  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__\n  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__\n\n  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)\n  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)\n\n  #define USE_SHADER_MODIFIER_SURFACE __USE_SHADER_MODIFIER_SURFACE__\n  #define USE_SHADER_MODIFIER_FRAGMENT __USE_SHADER_MODIFIER_FRAGMENT__\n\n  layout (std140) uniform cameraUniform {\n    vec4 position;\n    mat4 viewTransform;\n    mat4 inverseViewTransform;\n    mat4 viewProjectionTransform;\n  } camera;\n\n  layout (std140) uniform materialUniform {\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 normal;\n    vec4 reflective;\n    vec4 emission;\n    vec4 transparent;\n    vec4 multiply;\n    vec4 ambientOcclusion;\n    vec4 selfIllumination;\n    vec4 metalness;\n    vec4 roughness;\n    float shininess;\n    float fresnelExponent;\n  } material;\n\n  struct AmbientLight {\n    vec4 color;\n  };\n\n  struct SCNShaderLightingContribution {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n  } _lightingContribution;\n\n  struct DirectionalLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct DirectionalShadowLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n    vec4 shadowColor;\n    mat4 viewProjectionTransform;\n    mat4 shadowProjectionTransform;\n  };\n\n  struct OmniLight {\n    vec4 color;\n    vec4 position; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct ProbeLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct SpotLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  layout (std140) uniform lightUniform {\n    #if NUM_AMBIENT_LIGHTS > 0\n      AmbientLight ambient[NUM_AMBIENT_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    #endif\n    #if NUM_OMNI_LIGHTS > 0\n      OmniLight omni[NUM_OMNI_LIGHTS];\n    #endif\n    #if NUM_SPOT_LIGHTS > 0\n      SpotLight spot[NUM_SPOT_LIGHTS];\n    #endif\n    #if NUM_IES_LIGHTS > 0\n      IESLight ies[NUM_IES_LIGHTS];\n    #endif\n    #if NUM_PROBE_LIGHTS > 0\n      ProbeLight probe[NUM_PROBE_LIGHTS];\n    #endif\n    #if NUM_LIGHTS == 0\n      vec4 dummy;\n    #endif\n  } light;\n  #if NUM_SHADOW_LIGHTS > 0\n    in vec3 v_light[NUM_SHADOW_LIGHTS];\n  #endif\n  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n    in vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    in vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    uniform sampler2D u_shadowTexture0;\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 1\n      uniform sampler2D u_shadowTexture1;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 2\n      uniform sampler2D u_shadowTexture2;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 3\n      uniform sampler2D u_shadowTexture3;\n    #endif\n  #endif\n\n  layout (std140) uniform SCNLightsUniform {\n    vec4 direction0;\n    mat4 shadowMatrix0;\n  } scn_lights;\n\n  layout (std140) uniform fogUniform {\n    vec4 color;\n    float startDistance;\n    float endDistance;\n    float densityExponent;\n  } fog;\n\n  struct SCNShaderSurface {\n    vec3 view;\n    vec3 position;\n    vec3 normal;\n    vec2 normalTexcoord;\n    vec3 geometryNormal;\n    vec3 tangent;\n    vec3 bitangent;\n    vec4 ambient;\n    vec2 ambientTexcoord;\n    vec4 diffuse;\n    vec2 diffuseTexcoord;\n    vec4 specular;\n    vec2 specularTexcoord;\n    vec4 emission;\n    vec2 emissionTexcoord;\n    vec4 multiply;\n    vec2 multiplyTexcoord;\n    vec4 transparent;\n    vec2 transparentTexcoord;\n    vec4 reflective;\n    float ambientOcclusion;\n    float shininess;\n    float fresnel;\n    __USER_CUSTOM_SURFACE__\n  } _surface;\n\n  struct SCNShaderOutput {\n    vec4 color;\n  } _output;\n\n  vec2 poissonDisk[4] = vec2[](\n    vec2( -0.94201624, -0.39906216 ),\n    vec2( 0.94558609, -0.76890725 ),\n    vec2( -0.094184101, -0.92938870 ),\n    vec2( 0.34495938, 0.29387760 )\n  );\n\n  //#define kSCNTexcoordCount 2\n  //struct SCNShaderGeometry {\n  //  vec3 position;\n  //  vec3 normal;\n  //  vec4 tangent;\n  //  vec4 color;\n  //  vec2 texcoords[kSCNTexcoordCount];\n  //};\n\n  uniform float u_time;\n\n  in vec3 v_position;\n  in vec3 v_normal;\n  in vec2 v_texcoord0;\n  in vec2 v_texcoord1;\n  //in vec4 v_color;\n  in vec3 v_eye;\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  in float v_fogFactor;\n\n  //in SCNShaderGeometry _geometry;\n\n  out vec4 outColor;\n\n  __USER_CUSTOM_UNIFORM__\n\n  float saturate(float value) {\n    return clamp(value, 0.0, 1.0);\n  }\n\n  float convDepth(vec4 color) {\n    const float rMask = 1.0;\n    const float gMask = 1.0 / 255.0;\n    const float bMask = 1.0 / (255.0 * 255.0);\n    const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n    float depth = dot(color, vec4(rMask, gMask, bMask, aMask));\n    return depth * 2.0 - 1.0;\n  }\n\n  #if USE_SHADER_MODIFIER_SURFACE\n  void shaderModifierSurface() {\n    __SHADER_MODIFIER_SURFACE__\n  }\n  #endif\n\n  #if USE_SHADER_MODIFIER_FRAGMENT\n  void shaderModifierFragment() {\n    __SHADER_MODIFIER_FRAGMENT__\n  }\n  #endif\n\n    \n  void main() {\n    //_output.color = v_color;\n    //_output.color = vec4(0, 0, 0, 1);\n\n    //vec3 viewVec = normalize(v_eye);\n    //vec3 nom = normalize(v_normal);\n    _surface.view = normalize(v_eye);\n    _surface.position = v_position;\n    _surface.normal = normalize(v_normal);\n    _surface.tangent = normalize(v_tangent);\n    _surface.bitangent = normalize(v_bitangent);\n\n    // normal texture\n    if(textureFlags[TEXTURE_NORMAL_INDEX]){\n      mat3 tsInv = mat3(_surface.tangent, _surface.bitangent, _surface.normal);\n      vec3 color = normalize(texture(u_normalTexture, v_texcoord0).rgb * 2.0 - 1.0); // FIXME: check mappingChannel to decide which texture you use.\n      _surface.normal = normalize(tsInv * color);\n    }\n\n    //_surface.ambient = material.ambient;\n    _surface.ambient = vec4(0, 0, 0, 1); // FIXME: check: lock ambient with diffuse\n    _surface.diffuse = material.diffuse;\n    _surface.specular = material.specular;\n    _surface.emission = material.emission;\n    _surface.multiply = material.multiply;\n    _surface.transparent = material.transparent;\n    _surface.reflective = material.reflective;\n    _surface.ambientOcclusion = 1.0; // TODO: calculate AO\n    _surface.shininess = material.shininess;\n    _surface.fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent); // TODO: calculate coefficient\n\n    // TODO: check mapping channel for each material\n    _surface.ambientTexcoord = v_texcoord0;\n    _surface.diffuseTexcoord = v_texcoord0;\n    _surface.specularTexcoord = v_texcoord0;\n    if(selfIllumination){\n      _surface.emissionTexcoord = v_texcoord1;\n    }else{\n      _surface.emissionTexcoord = v_texcoord0;\n    }\n    _surface.multiplyTexcoord = v_texcoord0;\n    _surface.transparentTexcoord = v_texcoord0;\n\n    if(textureFlags[TEXTURE_AMBIENT_INDEX]){\n      _surface.ambient = texture(u_ambientTexture, _surface.ambientTexcoord);\n    }\n    if(textureFlags[TEXTURE_DIFFUSE_INDEX]){\n      _surface.diffuse = texture(u_diffuseTexture, _surface.diffuseTexcoord);\n      _surface.diffuse.a *= material.diffuse.a;\n    }\n    if(textureFlags[TEXTURE_SPECULAR_INDEX]){\n      _surface.specular = texture(u_specularTexture, _surface.specularTexcoord);\n    }\n    if(textureFlags[TEXTURE_EMISSION_INDEX]){\n      _surface.emission = texture(u_emissionTexture, _surface.emissionTexcoord);\n    }\n    if(textureFlags[TEXTURE_MULTIPLY_INDEX]){\n      _surface.multiply = texture(u_multiplyTexture, _surface.multiplyTexcoord);\n    }\n    if(textureFlags[TEXTURE_TRANSPARENT_INDEX]){\n      _surface.transparent = texture(u_transparentTexture, _surface.transparentTexcoord);\n    }\n\n    __USER_CUSTOM_TEXCOORD__\n\n    #if USE_SHADER_MODIFIER_SURFACE\n      shaderModifierSurface();\n    #endif\n\n    // Lighting\n    int numLights = 0;\n    _lightingContribution.ambient = vec3(0);\n    _lightingContribution.diffuse = vec3(0);\n    _lightingContribution.specular = vec3(0);\n\n    #if NUM_AMBIENT_LIGHTS > 0\n      for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){\n        _lightingContribution.ambient += light.ambient[i].color.rgb;\n      }\n    #endif\n\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.directional[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.directional[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(specular);\n        }\n      }\n      numLights += NUM_DIRECTIONAL_LIGHTS;\n    #endif\n\n    #if NUM_OMNI_LIGHTS > 0\n      for(int i=0; i<NUM_OMNI_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.omni[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.omni[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(1, 1, 1) * specular;\n        }\n      }\n      numLights += NUM_OMNI_LIGHTS;\n    #endif\n\n    #if NUM_SPOT_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_IES_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_PROBE_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    __FS_LIGHTING__\n\n\n    // calculate color\n    _output.color = vec4(0, 0, 0, _surface.diffuse.a);\n\n    vec3 D = _lightingContribution.diffuse;\n\n    // lock ambient with diffuse\n    D += _lightingContribution.ambient * _surface.ambientOcclusion;\n\n    // emission\n    if(selfIllumination){\n      D += _surface.emission.rgb;\n    }\n\n    // diffuse\n    _output.color.rgb = _surface.diffuse.rgb * D;\n\n    vec3 S = _lightingContribution.specular;\n    //S += _surface.reflective.rgb * _surface.ambientOcclusion;\n    S *= _surface.specular.rgb;\n    _output.color.rgb += S;\n\n    // ambient\n    _output.color.rgb += _surface.ambient.rgb * _lightingContribution.ambient;\n\n    if(!selfIllumination){\n      _output.color.rgb += _surface.emission.rgb;\n    }\n\n    // multiply\n    _output.color.rgb *= _surface.multiply.rgb;\n\n    // fresnel reflection\n    if(textureFlags[TEXTURE_REFLECTIVE_INDEX]){\n      vec3 r = reflect(_surface.view, _surface.normal);\n      //float fresnel = f0 + (1.0 - f0) * pow(1.0 - clamp(dot(viewVec, nom), 0.0, 1.0), material.fresnelExponent);\n      //float fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent);\n      _output.color.rgb += texture(u_reflectiveTexture, r).rgb * _surface.fresnel;\n    }\n\n    float fogFactor = pow(v_fogFactor, fog.densityExponent);\n    _output.color = mix(_output.color, fog.color, fogFactor);\n\n    _output.color.rgb *= _surface.diffuse.a;\n\n    #if USE_SHADER_MODIFIER_FRAGMENT\n      shaderModifierFragment();\n    #endif\n\n    if(_output.color.a <= 0.0){\n      // avoid overwriting the depth buffer\n      discard;\n    }\n\n    outColor = _output.color;\n\n    // linear To sRGB\n    //outColor.rgb = pow(_output.color.rgb, vec3(1.0/2.2));\n    //outColor.a = _output.color.a;\n  }\n"
                    },
                    "tail": true
                  }
                ]
              },
              "leadingComments": null
            }
          ],
          "kind": "const",
          "leadingComments": [
            {
              "type": "CommentBlock",
              "value": "*\n * @type {string}\n ",
              "start": 14,
              "end": 39,
              "loc": {
                "start": {
                  "line": 3,
                  "column": 0
                },
                "end": {
                  "line": 5,
                  "column": 3
                }
              }
            }
          ],
          "trailingComments": []
        }
      }
    ],
    "directives": [
      {
        "type": "Directive",
        "start": 0,
        "end": 12,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 12
          }
        },
        "value": {
          "type": "DirectiveLiteral",
          "start": 0,
          "end": 12,
          "loc": {
            "start": {
              "line": 1,
              "column": 0
            },
            "end": {
              "line": 1,
              "column": 12
            }
          },
          "value": "use strict",
          "extra": {
            "raw": "'use strict'",
            "rawValue": "use strict"
          },
          "trailingComments": null
        },
        "trailingComments": [
          {
            "type": "CommentBlock",
            "value": "*\n * @type {string}\n ",
            "start": 14,
            "end": 39,
            "loc": {
              "start": {
                "line": 3,
                "column": 0
              },
              "end": {
                "line": 5,
                "column": 3
              }
            }
          }
        ]
      }
    ]
  },
  "comments": [
    {
      "type": "CommentBlock",
      "value": "*\n * @type {string}\n ",
      "start": 14,
      "end": 39,
      "loc": {
        "start": {
          "line": 3,
          "column": 0
        },
        "end": {
          "line": 5,
          "column": 3
        }
      }
    }
  ],
  "tokens": [
    {
      "type": {
        "label": "string",
        "beforeExpr": false,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      },
      "value": "use strict",
      "start": 0,
      "end": 12,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 12
        }
      }
    },
    {
      "type": "CommentBlock",
      "value": "*\n * @type {string}\n ",
      "start": 14,
      "end": 39,
      "loc": {
        "start": {
          "line": 3,
          "column": 0
        },
        "end": {
          "line": 5,
          "column": 3
        }
      }
    },
    {
      "type": {
        "label": "const",
        "keyword": "const",
        "beforeExpr": false,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      },
      "value": "const",
      "start": 40,
      "end": 45,
      "loc": {
        "start": {
          "line": 6,
          "column": 0
        },
        "end": {
          "line": 6,
          "column": 5
        }
      }
    },
    {
      "type": {
        "label": "name",
        "beforeExpr": false,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      },
      "value": "_SCNDefaultFragmentShader",
      "start": 46,
      "end": 71,
      "loc": {
        "start": {
          "line": 6,
          "column": 6
        },
        "end": {
          "line": 6,
          "column": 31
        }
      }
    },
    {
      "type": {
        "label": "=",
        "beforeExpr": true,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": true,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      },
      "value": "=",
      "start": 72,
      "end": 73,
      "loc": {
        "start": {
          "line": 6,
          "column": 32
        },
        "end": {
          "line": 6,
          "column": 33
        }
      }
    },
    {
      "type": {
        "label": "`",
        "beforeExpr": false,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      },
      "start": 76,
      "end": 77,
      "loc": {
        "start": {
          "line": 7,
          "column": 1
        },
        "end": {
          "line": 7,
          "column": 2
        }
      }
    },
    {
      "type": {
        "label": "template",
        "beforeExpr": false,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      },
      "value": "#version 300 es\n  precision mediump float;\n  precision highp sampler2DShadow;\n\n  uniform bool[12] textureFlags;\n  #define TEXTURE_EMISSION_INDEX 0\n  #define TEXTURE_AMBIENT_INDEX 1\n  #define TEXTURE_DIFFUSE_INDEX 2\n  #define TEXTURE_SPECULAR_INDEX 3\n  #define TEXTURE_REFLECTIVE_INDEX 4\n  #define TEXTURE_TRANSPARENT_INDEX 5\n  #define TEXTURE_MULTIPLY_INDEX 6\n  #define TEXTURE_NORMAL_INDEX 7\n  #define TEXTURE_AMBIENT_OCCLUSION_INDEX 8\n  #define TEXTURE_SELF_ILLUMINATION_INDEX 9\n  #define TEXTURE_METALNESS_INDEX 10\n  #define TEXTURE_ROUGHNESS_INDEX 11\n\n  uniform bool selfIllumination;\n\n  uniform sampler2D u_emissionTexture;\n  uniform sampler2D u_ambientTexture;\n  uniform sampler2D u_diffuseTexture;\n  uniform sampler2D u_specularTexture;\n  uniform samplerCube u_reflectiveTexture;\n  uniform sampler2D u_transparentTexture;\n  uniform sampler2D u_multiplyTexture;\n  uniform sampler2D u_normalTexture;\n  uniform sampler2D u_ambientOcclusionTexture;\n  uniform sampler2D u_selfIlluminationTexture;\n  uniform sampler2D u_metalnessTexture;\n  uniform sampler2D u_roughnessTexture;\n\n  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__\n  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__\n  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__\n  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__\n  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__\n  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__\n  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__\n\n  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)\n  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)\n\n  #define USE_SHADER_MODIFIER_SURFACE __USE_SHADER_MODIFIER_SURFACE__\n  #define USE_SHADER_MODIFIER_FRAGMENT __USE_SHADER_MODIFIER_FRAGMENT__\n\n  layout (std140) uniform cameraUniform {\n    vec4 position;\n    mat4 viewTransform;\n    mat4 inverseViewTransform;\n    mat4 viewProjectionTransform;\n  } camera;\n\n  layout (std140) uniform materialUniform {\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 normal;\n    vec4 reflective;\n    vec4 emission;\n    vec4 transparent;\n    vec4 multiply;\n    vec4 ambientOcclusion;\n    vec4 selfIllumination;\n    vec4 metalness;\n    vec4 roughness;\n    float shininess;\n    float fresnelExponent;\n  } material;\n\n  struct AmbientLight {\n    vec4 color;\n  };\n\n  struct SCNShaderLightingContribution {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n  } _lightingContribution;\n\n  struct DirectionalLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct DirectionalShadowLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n    vec4 shadowColor;\n    mat4 viewProjectionTransform;\n    mat4 shadowProjectionTransform;\n  };\n\n  struct OmniLight {\n    vec4 color;\n    vec4 position; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct ProbeLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct SpotLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  layout (std140) uniform lightUniform {\n    #if NUM_AMBIENT_LIGHTS > 0\n      AmbientLight ambient[NUM_AMBIENT_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    #endif\n    #if NUM_OMNI_LIGHTS > 0\n      OmniLight omni[NUM_OMNI_LIGHTS];\n    #endif\n    #if NUM_SPOT_LIGHTS > 0\n      SpotLight spot[NUM_SPOT_LIGHTS];\n    #endif\n    #if NUM_IES_LIGHTS > 0\n      IESLight ies[NUM_IES_LIGHTS];\n    #endif\n    #if NUM_PROBE_LIGHTS > 0\n      ProbeLight probe[NUM_PROBE_LIGHTS];\n    #endif\n    #if NUM_LIGHTS == 0\n      vec4 dummy;\n    #endif\n  } light;\n  #if NUM_SHADOW_LIGHTS > 0\n    in vec3 v_light[NUM_SHADOW_LIGHTS];\n  #endif\n  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n    in vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    in vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    uniform sampler2D u_shadowTexture0;\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 1\n      uniform sampler2D u_shadowTexture1;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 2\n      uniform sampler2D u_shadowTexture2;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 3\n      uniform sampler2D u_shadowTexture3;\n    #endif\n  #endif\n\n  layout (std140) uniform SCNLightsUniform {\n    vec4 direction0;\n    mat4 shadowMatrix0;\n  } scn_lights;\n\n  layout (std140) uniform fogUniform {\n    vec4 color;\n    float startDistance;\n    float endDistance;\n    float densityExponent;\n  } fog;\n\n  struct SCNShaderSurface {\n    vec3 view;\n    vec3 position;\n    vec3 normal;\n    vec2 normalTexcoord;\n    vec3 geometryNormal;\n    vec3 tangent;\n    vec3 bitangent;\n    vec4 ambient;\n    vec2 ambientTexcoord;\n    vec4 diffuse;\n    vec2 diffuseTexcoord;\n    vec4 specular;\n    vec2 specularTexcoord;\n    vec4 emission;\n    vec2 emissionTexcoord;\n    vec4 multiply;\n    vec2 multiplyTexcoord;\n    vec4 transparent;\n    vec2 transparentTexcoord;\n    vec4 reflective;\n    float ambientOcclusion;\n    float shininess;\n    float fresnel;\n    __USER_CUSTOM_SURFACE__\n  } _surface;\n\n  struct SCNShaderOutput {\n    vec4 color;\n  } _output;\n\n  vec2 poissonDisk[4] = vec2[](\n    vec2( -0.94201624, -0.39906216 ),\n    vec2( 0.94558609, -0.76890725 ),\n    vec2( -0.094184101, -0.92938870 ),\n    vec2( 0.34495938, 0.29387760 )\n  );\n\n  //#define kSCNTexcoordCount 2\n  //struct SCNShaderGeometry {\n  //  vec3 position;\n  //  vec3 normal;\n  //  vec4 tangent;\n  //  vec4 color;\n  //  vec2 texcoords[kSCNTexcoordCount];\n  //};\n\n  uniform float u_time;\n\n  in vec3 v_position;\n  in vec3 v_normal;\n  in vec2 v_texcoord0;\n  in vec2 v_texcoord1;\n  //in vec4 v_color;\n  in vec3 v_eye;\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  in float v_fogFactor;\n\n  //in SCNShaderGeometry _geometry;\n\n  out vec4 outColor;\n\n  __USER_CUSTOM_UNIFORM__\n\n  float saturate(float value) {\n    return clamp(value, 0.0, 1.0);\n  }\n\n  float convDepth(vec4 color) {\n    const float rMask = 1.0;\n    const float gMask = 1.0 / 255.0;\n    const float bMask = 1.0 / (255.0 * 255.0);\n    const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n    float depth = dot(color, vec4(rMask, gMask, bMask, aMask));\n    return depth * 2.0 - 1.0;\n  }\n\n  #if USE_SHADER_MODIFIER_SURFACE\n  void shaderModifierSurface() {\n    __SHADER_MODIFIER_SURFACE__\n  }\n  #endif\n\n  #if USE_SHADER_MODIFIER_FRAGMENT\n  void shaderModifierFragment() {\n    __SHADER_MODIFIER_FRAGMENT__\n  }\n  #endif\n\n    \n  void main() {\n    //_output.color = v_color;\n    //_output.color = vec4(0, 0, 0, 1);\n\n    //vec3 viewVec = normalize(v_eye);\n    //vec3 nom = normalize(v_normal);\n    _surface.view = normalize(v_eye);\n    _surface.position = v_position;\n    _surface.normal = normalize(v_normal);\n    _surface.tangent = normalize(v_tangent);\n    _surface.bitangent = normalize(v_bitangent);\n\n    // normal texture\n    if(textureFlags[TEXTURE_NORMAL_INDEX]){\n      mat3 tsInv = mat3(_surface.tangent, _surface.bitangent, _surface.normal);\n      vec3 color = normalize(texture(u_normalTexture, v_texcoord0).rgb * 2.0 - 1.0); // FIXME: check mappingChannel to decide which texture you use.\n      _surface.normal = normalize(tsInv * color);\n    }\n\n    //_surface.ambient = material.ambient;\n    _surface.ambient = vec4(0, 0, 0, 1); // FIXME: check: lock ambient with diffuse\n    _surface.diffuse = material.diffuse;\n    _surface.specular = material.specular;\n    _surface.emission = material.emission;\n    _surface.multiply = material.multiply;\n    _surface.transparent = material.transparent;\n    _surface.reflective = material.reflective;\n    _surface.ambientOcclusion = 1.0; // TODO: calculate AO\n    _surface.shininess = material.shininess;\n    _surface.fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent); // TODO: calculate coefficient\n\n    // TODO: check mapping channel for each material\n    _surface.ambientTexcoord = v_texcoord0;\n    _surface.diffuseTexcoord = v_texcoord0;\n    _surface.specularTexcoord = v_texcoord0;\n    if(selfIllumination){\n      _surface.emissionTexcoord = v_texcoord1;\n    }else{\n      _surface.emissionTexcoord = v_texcoord0;\n    }\n    _surface.multiplyTexcoord = v_texcoord0;\n    _surface.transparentTexcoord = v_texcoord0;\n\n    if(textureFlags[TEXTURE_AMBIENT_INDEX]){\n      _surface.ambient = texture(u_ambientTexture, _surface.ambientTexcoord);\n    }\n    if(textureFlags[TEXTURE_DIFFUSE_INDEX]){\n      _surface.diffuse = texture(u_diffuseTexture, _surface.diffuseTexcoord);\n      _surface.diffuse.a *= material.diffuse.a;\n    }\n    if(textureFlags[TEXTURE_SPECULAR_INDEX]){\n      _surface.specular = texture(u_specularTexture, _surface.specularTexcoord);\n    }\n    if(textureFlags[TEXTURE_EMISSION_INDEX]){\n      _surface.emission = texture(u_emissionTexture, _surface.emissionTexcoord);\n    }\n    if(textureFlags[TEXTURE_MULTIPLY_INDEX]){\n      _surface.multiply = texture(u_multiplyTexture, _surface.multiplyTexcoord);\n    }\n    if(textureFlags[TEXTURE_TRANSPARENT_INDEX]){\n      _surface.transparent = texture(u_transparentTexture, _surface.transparentTexcoord);\n    }\n\n    __USER_CUSTOM_TEXCOORD__\n\n    #if USE_SHADER_MODIFIER_SURFACE\n      shaderModifierSurface();\n    #endif\n\n    // Lighting\n    int numLights = 0;\n    _lightingContribution.ambient = vec3(0);\n    _lightingContribution.diffuse = vec3(0);\n    _lightingContribution.specular = vec3(0);\n\n    #if NUM_AMBIENT_LIGHTS > 0\n      for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){\n        _lightingContribution.ambient += light.ambient[i].color.rgb;\n      }\n    #endif\n\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.directional[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.directional[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(specular);\n        }\n      }\n      numLights += NUM_DIRECTIONAL_LIGHTS;\n    #endif\n\n    #if NUM_OMNI_LIGHTS > 0\n      for(int i=0; i<NUM_OMNI_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.omni[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.omni[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(1, 1, 1) * specular;\n        }\n      }\n      numLights += NUM_OMNI_LIGHTS;\n    #endif\n\n    #if NUM_SPOT_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_IES_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_PROBE_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    __FS_LIGHTING__\n\n\n    // calculate color\n    _output.color = vec4(0, 0, 0, _surface.diffuse.a);\n\n    vec3 D = _lightingContribution.diffuse;\n\n    // lock ambient with diffuse\n    D += _lightingContribution.ambient * _surface.ambientOcclusion;\n\n    // emission\n    if(selfIllumination){\n      D += _surface.emission.rgb;\n    }\n\n    // diffuse\n    _output.color.rgb = _surface.diffuse.rgb * D;\n\n    vec3 S = _lightingContribution.specular;\n    //S += _surface.reflective.rgb * _surface.ambientOcclusion;\n    S *= _surface.specular.rgb;\n    _output.color.rgb += S;\n\n    // ambient\n    _output.color.rgb += _surface.ambient.rgb * _lightingContribution.ambient;\n\n    if(!selfIllumination){\n      _output.color.rgb += _surface.emission.rgb;\n    }\n\n    // multiply\n    _output.color.rgb *= _surface.multiply.rgb;\n\n    // fresnel reflection\n    if(textureFlags[TEXTURE_REFLECTIVE_INDEX]){\n      vec3 r = reflect(_surface.view, _surface.normal);\n      //float fresnel = f0 + (1.0 - f0) * pow(1.0 - clamp(dot(viewVec, nom), 0.0, 1.0), material.fresnelExponent);\n      //float fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent);\n      _output.color.rgb += texture(u_reflectiveTexture, r).rgb * _surface.fresnel;\n    }\n\n    float fogFactor = pow(v_fogFactor, fog.densityExponent);\n    _output.color = mix(_output.color, fog.color, fogFactor);\n\n    _output.color.rgb *= _surface.diffuse.a;\n\n    #if USE_SHADER_MODIFIER_FRAGMENT\n      shaderModifierFragment();\n    #endif\n\n    if(_output.color.a <= 0.0){\n      // avoid overwriting the depth buffer\n      discard;\n    }\n\n    outColor = _output.color;\n\n    // linear To sRGB\n    //outColor.rgb = pow(_output.color.rgb, vec3(1.0/2.2));\n    //outColor.a = _output.color.a;\n  }\n",
      "start": 77,
      "end": 13364,
      "loc": {
        "start": {
          "line": 7,
          "column": 2
        },
        "end": {
          "line": 456,
          "column": 0
        }
      }
    },
    {
      "type": {
        "label": "`",
        "beforeExpr": false,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      },
      "start": 13364,
      "end": 13365,
      "loc": {
        "start": {
          "line": 456,
          "column": 0
        },
        "end": {
          "line": 456,
          "column": 1
        }
      }
    },
    {
      "type": {
        "label": "export",
        "keyword": "export",
        "beforeExpr": false,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      },
      "value": "export",
      "start": 13367,
      "end": 13373,
      "loc": {
        "start": {
          "line": 458,
          "column": 0
        },
        "end": {
          "line": 458,
          "column": 6
        }
      }
    },
    {
      "type": {
        "label": "default",
        "keyword": "default",
        "beforeExpr": true,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      },
      "value": "default",
      "start": 13374,
      "end": 13381,
      "loc": {
        "start": {
          "line": 458,
          "column": 7
        },
        "end": {
          "line": 458,
          "column": 14
        }
      }
    },
    {
      "type": {
        "label": "name",
        "beforeExpr": false,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      },
      "value": "_SCNDefaultFragmentShader",
      "start": 13382,
      "end": 13407,
      "loc": {
        "start": {
          "line": 458,
          "column": 15
        },
        "end": {
          "line": 458,
          "column": 40
        }
      }
    },
    {
      "type": {
        "label": "eof",
        "beforeExpr": false,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      },
      "start": 13409,
      "end": 13409,
      "loc": {
        "start": {
          "line": 460,
          "column": 0
        },
        "end": {
          "line": 460,
          "column": 0
        }
      }
    }
  ]
}